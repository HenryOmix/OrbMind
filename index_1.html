<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Neon Fluid Orb: Rain Edition</title>

  <!-- PWA -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#050508">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Neon Orb">
  <link rel="apple-touch-icon" href="icons/icon-192.png">
  <link rel="icon" type="image/png" href="icons/icon-192.png">

  <style>
    * {
      box-sizing: border-box;
      padding: 0;
      margin: 0;
    }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #050505; /* Deep black */
      font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    #ui-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: space-between;
      padding: 40px;
    }
    
    /* SETTINGS TOGGLE (Top Right) */
    .settings-trigger {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(4px);
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
      transition: background 0.3s, transform 0.2s;
      opacity: 0.4; /* Semi-transparent */
      z-index: 200;
    }
    /* Ring to visualize the 3s hold */
    .settings-ring {
      position: absolute;
      top: 0; left: 0;
      width: 44px; height: 44px;
      border-radius: 50%;
      border: 2px solid #00f3ff;
      opacity: 0;
      transform: scale(1.2);
      transition: opacity 0.3s;
    }
    
    .score-container {
      text-align: center;
      color: rgba(255, 255, 255, 0.8);
      text-shadow: 0 0 20px rgba(0, 243, 255, 0.5);
      margin-top: 60px; /* Space for settings */
    }
    #score-display {
      font-size: 60px;
      font-weight: 200;
      letter-spacing: 2px;
    }
    .hint {
      font-size: 14px;
      color: rgba(255, 255, 255, 0.4);
      margin-top: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    /* SETTINGS MENU (Hidden by default) */
    #settings-menu {
      position: absolute;
      top: 80px; right: 20px;
      background: rgba(10, 15, 20, 0.9);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 12px;
      padding: 15px;
      color: #fff;
      display: none;
      pointer-events: auto;
      min-width: 200px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    }
    #settings-menu.visible { display: block; }
    .menu-item {
      display: flex; justify-content: space-between;
      margin-bottom: 10px; font-size: 14px;
    }
    .menu-item:last-child { margin-bottom: 0; }
  </style>
</head>
<body>

  <div id="ui-layer">
    <!-- 3-Second Hold Trigger -->
    <div class="settings-trigger" id="settings-trigger">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="white">
        <path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.49l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/>
      </svg>
      <div class="settings-ring" id="settings-ring"></div>
    </div>
    
    <!-- Minimal Menu -->
    <div id="settings-menu">
      <div class="menu-item">
        <span>Volume</span>
        <span>50%</span>
      </div>
      <div class="menu-item">
        <span>Haptics</span>
        <span>ON</span>
      </div>
    </div>

    <div class="score-container">
      <div id="score-display">0</div>
      <div class="hint" id="hint-text">Hold & Release to Impulse</div>
    </div>
  </div>

  <canvas id="game"></canvas>

  <script>
    // --- AUDIO ENGINE: NEUROCALM (40Hz + Pink Noise + Singing Bowl) ---
    let actx, master, filterNode;
    let audioInitialized = false;

    function initAudio() {
      if (audioInitialized) return;
      const AC = window.AudioContext || window.webkitAudioContext;
      actx = new AC();
      master = actx.createGain();
      master.gain.value = 0.45;
      master.connect(actx.destination);

      // 1. Pink Noise (Atmosphere)
      const bufferSize = 4096;
      const pinkNoise = (function() {
          let b0=0, b1=0, b2=0, b3=0, b4=0, b5=0, b6=0;
          const node = actx.createScriptProcessor(bufferSize, 1, 1);
          node.onaudioprocess = function(e) {
              const output = e.outputBuffer.getChannelData(0);
              for (let i = 0; i < bufferSize; i++) {
                  const white = Math.random() * 2 - 1;
                  b0 = 0.99886 * b0 + white * 0.0555179;
                  b1 = 0.99332 * b1 + white * 0.0750759;
                  b2 = 0.96900 * b2 + white * 0.1538520;
                  b3 = 0.86650 * b3 + white * 0.3104856;
                  b4 = 0.55000 * b4 + white * 0.5329522;
                  b5 = -0.7616 * b5 - white * 0.0168980;
                  output[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
                  output[i] *= 0.11; 
                  b6 = white * 0.115926;
              }
          };
          return node;
      })();

      filterNode = actx.createBiquadFilter();
      filterNode.type = 'lowpass';
      filterNode.Q.value = 1;
      filterNode.frequency.value = 200; 

      pinkNoise.connect(filterNode);
      filterNode.connect(master);

      // 2. 40Hz Gamma Entrainment
      const carrier = actx.createOscillator();
      carrier.frequency.value = 200; 
      const mod = actx.createOscillator();
      mod.frequency.value = 40; 
      const modGain = actx.createGain();
      modGain.gain.value = 50; 
      const carrierGain = actx.createGain();
      carrierGain.gain.value = 0.03; 

      mod.connect(modGain);
      modGain.connect(carrier.frequency); 
      carrier.connect(carrierGain).connect(master);
      
      carrier.start();
      mod.start();
      audioInitialized = true;
    }

    function updateAudioBreath(time) {
      if(!filterNode) return;
      const breathPhase = (Math.sin(time * 0.8) + 1) / 2; 
      const minFreq = 150;
      const maxFreq = 650;
      const freq = minFreq + (breathPhase * (maxFreq - minFreq));
      filterNode.frequency.setTargetAtTime(freq, actx.currentTime, 0.1);
    }

    function playSound(type) {
      if(!actx) return;
      const now = actx.currentTime;
      const osc = actx.createOscillator();
      const g = actx.createGain();
      osc.connect(g).connect(master);

      if (type === 'charge') {
        osc.frequency.setValueAtTime(100, now);
        osc.frequency.linearRampToValueAtTime(300, now + 1);
        g.gain.setValueAtTime(0, now);
        g.gain.linearRampToValueAtTime(0.1, now + 1);
        osc.start(now); osc.stop(now + 1.2);
      } else if (type === 'push') {
        osc.frequency.setValueAtTime(200, now);
        osc.frequency.exponentialRampToValueAtTime(50, now + 0.3);
        g.gain.setValueAtTime(0.2, now);
        g.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
        osc.start(now); osc.stop(now + 0.3);
      } else if (type === 'wall') {
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.exponentialRampToValueAtTime(80, now + 0.05);
        g.gain.setValueAtTime(0.1, now);
        g.gain.linearRampToValueAtTime(0, now + 0.05);
        osc.start(now); osc.stop(now + 0.05);
      } else if (type === 'success') {
        // GENTLEST SOUND: Tibetan Bowl Resonance
        // Low frequency sine wave with long attack/release
        osc.type = 'sine';
        osc.frequency.setValueAtTime(174, now); // 174Hz (Solfeggio frequency for pain/stress)
        
        // Soft Attack
        g.gain.setValueAtTime(0, now);
        g.gain.linearRampToValueAtTime(0.25, now + 0.1);
        // Long Decay
        g.gain.exponentialRampToValueAtTime(0.001, now + 2.5);
        
        osc.start(now); 
        osc.stop(now + 2.5);
      }
    }

    // --- RAIN HAPTICS ENGINE ---
    const Haptics = {
      active: ('vibrate' in navigator),
      
      grain: () => { if (Haptics.active) navigator.vibrate(3); },
      recoil: () => { if (Haptics.active) navigator.vibrate(25); },
      wall: () => { if (Haptics.active) navigator.vibrate(8); },
      
      // EXQUISITE RAIN SIMULATION
      rain: () => {
        if (!Haptics.active) return;
        // Generate a stochastic pattern of micro-pulses (3-6ms) with random gaps
        const drops = [];
        const count = 8; // Number of droplets
        for(let i=0; i<count; i++) {
           drops.push(Math.floor(3 + Math.random() * 4)); // Pulse duration
           drops.push(Math.floor(20 + Math.random() * 60)); // Gap duration
        }
        navigator.vibrate(drops);
      }
    };

    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d", { alpha: false }); 
    const scoreEl = document.getElementById("score-display");
    const hintEl = document.getElementById("hint-text");

    // --- CONFIG ---
    let width, height;
    let pixelRatio = 1;

    // Colors
    const COLOR_BG = "#050508";
    const COLOR_ORB = "#ffffff";
    const COLOR_ORB_GLOW = "#00f3ff"; // Cyan
    const COLOR_TARGET = "#ff0055";   // Pink
    const COLOR_TRAIL = "#00f3ff";

    // --- GAME STATE ---
    const orb = {
      x: 0, y: 0,
      vx: 0, vy: 0,
      radius: 20,
      mass: 1
    };

    const target = {
      x: 0, y: 0,
      radius: 55,
      angle: 0
    };

    let score = 0;
    
    // Interaction
    let isPressing = false;
    let pressStartPos = { x: 0, y: 0 };
    let pressStartTime = 0;
    let frameCount = 0; 

    // Visuals Arrays
    const particles = [];
    const stars = [];
    const trail = [];
    
    // Screen shake
    let shakeIntensity = 0;

    // --- RESIZE ---
    function resize() {
      pixelRatio = window.devicePixelRatio || 1;
      width = window.innerWidth;
      height = window.innerHeight;
      
      canvas.width = width * pixelRatio;
      canvas.height = height * pixelRatio;
      
      ctx.setTransform(1,0,0,1,0,0);
      ctx.scale(pixelRatio, pixelRatio);
      // Initialize orb center if first run
      if (orb.x === 0) {
        orb.x = width / 2;
        orb.y = height / 2;
        placeTarget();
        initStars();
      }
    }
    window.addEventListener("resize", resize);
    resize();

    // --- SETUP HELPERS ---
    function placeTarget() {
      const margin = 100;
      target.x = margin + Math.random() * (width - margin * 2);
      target.y = margin + Math.random() * (height - margin * 2);
    }

    function initStars() {
      for(let i=0; i<80; i++) {
        stars.push({
          x: Math.random() * width,
          y: Math.random() * height,
          size: Math.random() * 2,
          alpha: Math.random()
        });
      }
    }

    // --- SETTINGS UI LOGIC (3s Hold) ---
    const trigger = document.getElementById('settings-trigger');
    const ring = document.getElementById('settings-ring');
    const menu = document.getElementById('settings-menu');
    let holdTimer = null;
    let holdStartTime = 0;
    let holdingSettings = false;

    function startSettingsHold(e) {
      e.preventDefault(); 
      e.stopPropagation();
      holdingSettings = true;
      holdStartTime = performance.now();
      
      trigger.style.opacity = 1.0;
      ring.style.opacity = 1;
      ring.style.transition = "transform 3s linear";
      ring.style.transform = "scale(0)"; // Shrink ring to center over 3s
      
      holdTimer = setTimeout(() => {
        // Activation
        menu.classList.toggle('visible');
        Haptics.recoil(); // Confirm open
        endSettingsHold();
      }, 3000);
    }

    function endSettingsHold() {
      clearTimeout(holdTimer);
      holdingSettings = false;
      trigger.style.opacity = 0.4;
      
      // Reset ring
      ring.style.transition = "none";
      ring.style.transform = "scale(1.2)";
      ring.style.opacity = 0;
    }

    trigger.addEventListener('mousedown', startSettingsHold);
    trigger.addEventListener('touchstart', startSettingsHold, {passive: false});
    window.addEventListener('mouseup', endSettingsHold);
    window.addEventListener('touchend', endSettingsHold);


    // --- INPUT HANDLING (Game) ---
    function onDown(x, y) {
      if(holdingSettings) return; // Don't play if touching settings

      // Init Audio on first interaction
      if (!audioInitialized) initAudio();
      if (actx && actx.state === 'suspended') actx.resume();

      isPressing = true;
      pressStartPos = { x, y };
      pressStartTime = performance.now();
      hintEl.style.opacity = 0; 
      
      Haptics.grain();
      playSound('charge');
    }

    function onUp() {
      if (!isPressing) return;
      isPressing = false;
      
      const now = performance.now();
      let duration = now - pressStartTime;
      
      const minDur = 40;
      const maxDur = 800; 
      if (duration < minDur) duration = minDur;
      if (duration > maxDur) duration = maxDur;

      let dx = orb.x - pressStartPos.x;
      let dy = orb.y - pressStartPos.y;
      let dist = Math.hypot(dx, dy);
      if (dist < 0.1) dist = 0.1; 

      const nx = dx / dist;
      const ny = dy / dist;

      const strength = duration / maxDur; 
      const power = 1000 * strength; 
      orb.vx += nx * power;
      orb.vy += ny * power;

      createExplosion(orb.x, orb.y, 10, COLOR_ORB_GLOW);
      shakeIntensity = 5 * strength;

      Haptics.recoil();
      playSound('push');
    }

    canvas.addEventListener("mousedown", e => onDown(e.clientX, e.clientY));
    window.addEventListener("mouseup", onUp);
    canvas.addEventListener("touchstart", e => {
      e.preventDefault();
      onDown(e.touches[0].clientX, e.touches[0].clientY);
    }, { passive: false });
    window.addEventListener("touchend", onUp);

    // --- PARTICLE SYSTEM ---
    function createExplosion(x, y, count, color) {
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 4 + 1;
        particles.push({
          x: x, 
          y: y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 1.0,
          decay: Math.random() * 0.03 + 0.01,
          color: color,
          size: Math.random() * 3 + 1
        });
      }
    }

    // --- GAME LOOP ---
    let lastTime = performance.now();

    function loop(time) {
      const dt = Math.min(0.05, (time - lastTime) / 1000);
      lastTime = time;

      update(dt, time / 1000);
      draw();
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    function update(dt, timeInSeconds) {
      frameCount++;

      if(audioInitialized) updateAudioBreath(timeInSeconds);

      if (isPressing && frameCount % 6 === 0) {
        Haptics.grain();
      }

      // 1. Physics (Increased Gravity by 5%: 45 -> 47.25)
      orb.vy += 47.25 * dt; 
      orb.x += orb.vx * dt;
      orb.y += orb.vy * dt;

      const drag = 0.98;
      orb.vx *= drag;
      orb.vy *= drag;

      const r = orb.radius;
      let hitWall = false;
      if (orb.x < r) { orb.x = r; orb.vx *= -0.7; hitWall = true; }
      if (orb.x > width - r) { orb.x = width - r; orb.vx *= -0.7; hitWall = true; }
      if (orb.y < r) { orb.y = r; orb.vy *= -0.7; hitWall = true; }
      if (orb.y > height - r) { orb.y = height - r; orb.vy *= -0.7; hitWall = true; }

      if (hitWall) {
        if (Math.abs(orb.vx) + Math.abs(orb.vy) > 20) {
           Haptics.wall();
           playSound('wall');
           shakeIntensity = Math.min(shakeIntensity + 2, 10);
        }
      }

      shakeIntensity *= 0.9;
      if (shakeIntensity < 0.1) shakeIntensity = 0;

      trail.push({ x: orb.x, y: orb.y, size: orb.radius });
      if (trail.length > 20) trail.shift();

      const dx = orb.x - target.x;
      const dy = orb.y - target.y;
      const dist = Math.hypot(dx, dy);
      
      target.angle += dt; 

      // Check Score
      if (dist < target.radius - orb.radius * 0.5) {
        score++;
        scoreEl.innerText = score;
        scoreEl.style.transform = "scale(1.4)"; 
        setTimeout(() => scoreEl.style.transform = "scale(1)", 150);
        
        createExplosion(target.x, target.y, 40, COLOR_TARGET);
        createExplosion(target.x, target.y, 20, "#ffffff");
        shakeIntensity = 15;

        // Feedback: Rain + Gentle Sound
        Haptics.rain();
        playSound('success');
        
        placeTarget();
      }

      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life -= p.decay;
        p.size *= 0.95;
        if (p.life <= 0) particles.splice(i, 1);
      }
    }

    function draw() {
      ctx.fillStyle = COLOR_BG;
      ctx.fillRect(0, 0, width, height);

      ctx.save();
      
      if (shakeIntensity > 0) {
        const sx = (Math.random() - 0.5) * shakeIntensity;
        const sy = (Math.random() - 0.5) * shakeIntensity;
        ctx.translate(sx, sy);
      }

      ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
      stars.forEach(s => {
        s.y += s.size * 0.05;
        if(s.y > height) s.y = 0;
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.size, 0, Math.PI*2);
        ctx.fill();
      });

      ctx.globalCompositeOperation = "lighter";

      if (isPressing) {
        const now = performance.now();
        const dur = Math.min(now - pressStartTime, 800);
        const strength = dur / 800; 

        const dx = orb.x - pressStartPos.x;
        const dy = orb.y - pressStartPos.y;
        
        const grad = ctx.createLinearGradient(pressStartPos.x, pressStartPos.y, orb.x, orb.y);
        grad.addColorStop(0, "rgba(255, 255, 255, 0)");
        grad.addColorStop(1, "rgba(255, 0, 85, 0.8)"); 

        ctx.strokeStyle = grad;
        ctx.lineWidth = 2 + strength * 4;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(pressStartPos.x, pressStartPos.y);
        ctx.lineTo(orb.x, orb.y);
        ctx.stroke();
        ctx.setLineDash([]);

        ctx.strokeStyle = `rgba(255, 255, 255, ${0.3 + strength * 0.4})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(pressStartPos.x, pressStartPos.y, 20 + strength * 10, 0, Math.PI*2);
        ctx.stroke();
      }

      drawTarget();

      if (trail.length > 1) {
        ctx.beginPath();
        ctx.moveTo(trail[0].x, trail[0].y);
        for (let i = 1; i < trail.length; i++) {
            const xc = (trail[i].x + trail[i - 1].x) / 2;
            const yc = (trail[i].y + trail[i - 1].y) / 2;
            ctx.quadraticCurveTo(trail[i - 1].x, trail[i - 1].y, xc, yc);
        }
        ctx.lineTo(orb.x, orb.y);
        
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.lineWidth = orb.radius * 0.8;
        ctx.strokeStyle = "rgba(0, 243, 255, 0.15)";
        ctx.stroke();
        
        ctx.lineWidth = orb.radius * 0.3;
        ctx.strokeStyle = "rgba(0, 243, 255, 0.4)";
        ctx.stroke();
      }

      drawOrb();

      for (const p of particles) {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.globalAlpha = 1.0;

      ctx.restore();
    }

    function drawTarget() {
      const x = target.x;
      const y = target.y;
      const r = target.radius;

      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(target.angle);

      const glow = ctx.createRadialGradient(0, 0, r * 0.5, 0, 0, r * 1.5);
      glow.addColorStop(0, "rgba(255, 0, 85, 0)");
      glow.addColorStop(0.5, "rgba(255, 0, 85, 0.2)");
      glow.addColorStop(1, "rgba(255, 0, 85, 0)");
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(0, 0, r * 1.5, 0, Math.PI*2);
      ctx.fill();

      ctx.strokeStyle = COLOR_TARGET;
      ctx.lineWidth = 3;
      
      ctx.beginPath();
      ctx.arc(0, 0, r, 0, Math.PI * 1.5);
      ctx.stroke();

      ctx.rotate(Math.PI);
      ctx.beginPath();
      ctx.arc(0, 0, r * 0.8, 0, Math.PI * 1.5);
      ctx.strokeStyle = "#ff88aa";
      ctx.stroke();

      ctx.restore();
    }

    function drawOrb() {
      const x = orb.x;
      const y = orb.y;
      const r = orb.radius;

      const grad1 = ctx.createRadialGradient(x, y, r * 0.2, x, y, r * 2.5);
      grad1.addColorStop(0, "rgba(0, 243, 255, 0.8)");
      grad1.addColorStop(0.5, "rgba(0, 243, 255, 0.1)");
      grad1.addColorStop(1, "rgba(0, 0, 0, 0)");

      ctx.fillStyle = grad1;
      ctx.beginPath();
      ctx.arc(x, y, r * 2.5, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.arc(x, y, r * 0.7, 0, Math.PI * 2);
      ctx.fill();
    }


    // --- PWA: Service Worker registration (offline + install) ---
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js').catch(() => {});
      });
    }

  </script>
</body>
</html>
